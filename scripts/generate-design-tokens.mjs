#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import StyleDictionary from 'style-dictionary';
import { register, expandTypesMap } from '@tokens-studio/sd-transforms';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = path.resolve(__dirname, '..');
const TOKENS_DIR = path.join(ROOT_DIR, 'src', 'tokens');
const TOKENS_FILE = path.join(TOKENS_DIR, 'tokens.json');
const THEMES_OUTPUT_DIR = path.join(ROOT_DIR, 'src', 'styles', 'themes');
const MANIFEST_PATH = path.join(THEMES_OUTPUT_DIR, 'tokens.generated.ts');
const STORYBOOK_TOKEN_OPTIONS_PATH = path.join(
  THEMES_OUTPUT_DIR,
  'storybook-token-options.generated.ts',
);

const TARGET_THEMES = ['Engage', 'Legacy'];
const CSS_BANNER = `/*\n * -----------------------------------------------------------------------------\n * This file is auto-generated via scripts/generate-design-tokens.mjs.\n * Do not edit this file directly.\n * -----------------------------------------------------------------------------\n */\n\n`;
const TS_BANNER = `/**\n * -----------------------------------------------------------------------------\n * This file is auto-generated via scripts/generate-design-tokens.mjs.\n * Do not edit this file directly.\n * -----------------------------------------------------------------------------\n */\n\n`;

const slugify = (value) =>
  value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .replace(/-{2,}/g, '-');

const ensureBanner = (content, banner) => (content.startsWith(banner) ? content : `${banner}${content}`);
const FIVRA_THEME_ATTRIBUTE = 'data-fivra-theme';
const FONT_WEIGHT_NAME_TO_VALUE = {
  light: '300',
  regular: '380',
  medium: '570',
  semibold: '670',
  'semi-bold': '670',
};

const formatPercentValue = (value) => {
  const percent = value * 100;
  if (!Number.isFinite(percent)) {
    return null;
  }

  const formatted = Number.parseFloat(percent.toFixed(4)).toString();
  return `${formatted}%`;
};

const appendIntensityCompanionTokens = (cssContent) =>
  cssContent.replace(/(^\s*)(--intensity[A-Za-z0-9]+):\s*([0-9.]+);([ \t]*\r?\n)/gm, (match, indent, tokenName, rawValue, newline) => {
    if (tokenName.endsWith('Percent')) {
      return match;
    }

    const numericValue = Number.parseFloat(rawValue);
    if (!Number.isFinite(numericValue)) {
      return match;
    }

    const percentValue = formatPercentValue(numericValue);
    if (!percentValue) {
      return match;
    }

    return `${indent}${tokenName}: ${rawValue};${newline}${indent}${tokenName}Percent: ${percentValue};${newline}`;
  });

const ensureStateLayerAliases = (cssContent) => {
  const aliases = [
    { name: '--stateLayerBrightenBase', value: 'var(--backgroundNeutral0)' },
    { name: '--stateLayerDarkenBase', value: 'var(--backgroundNeutral1)' },
  ];

  return cssContent.replace(/(:root[^{]*\{)([\s\S]*?)(\n\})/, (match, prefix, body, suffix) => {
    let nextBody = body;
    const indent = '  ';

    for (const alias of aliases) {
      if (!nextBody.includes(`${alias.name}:`)) {
        const separator = nextBody.endsWith('\n') ? '' : '\n';
        nextBody = `${nextBody}${separator}${indent}${alias.name}: ${alias.value};\n`;
      }
    }

    return `${prefix}${nextBody}${suffix}`;
  });
};

const clearGeneratedThemeArtifacts = async () => {
  await fs.mkdir(THEMES_OUTPUT_DIR, { recursive: true });
  const entries = await fs.readdir(THEMES_OUTPUT_DIR, { withFileTypes: true }).catch(() => []);
  const generatedFileNames = new Set(['tokens.generated.ts', 'storybook-token-options.generated.ts']);

  await Promise.all(
    entries
      .filter((entry) =>
        entry.isFile() && (entry.name.endsWith('.css') || generatedFileNames.has(entry.name)),
      )
      .map((entry) => fs.unlink(path.join(THEMES_OUTPUT_DIR, entry.name))),
  );
};

const formatThemeSelector = ({ slug, isDefault }) => {
  const attributeSelector = `[${FIVRA_THEME_ATTRIBUTE}='${slug}']`;
  return isDefault ? `:root, ${attributeSelector}` : attributeSelector;
};

const rewriteRootSelector = ({ cssContent, selector }) => {
  const pattern = /^:root(\s*\{)/gm;
  return cssContent.replace(pattern, `${selector}$1`);
};

const readJson = async (filePath) => {
  const content = await fs.readFile(filePath, 'utf8');
  return JSON.parse(content);
};

const normalizeFontWeightTokens = (node) => {
  if (!node || typeof node !== 'object') {
    return;
  }

  if (!Array.isArray(node) && node.$type === 'fontWeights' && typeof node.$value === 'string') {
    const normalized = node.$value.trim().toLowerCase();
    const mapped = FONT_WEIGHT_NAME_TO_VALUE[normalized];
    if (mapped) {
      node.$value = mapped;
    }
  }

  for (const value of Object.values(node)) {
    if (value && typeof value === 'object') {
      normalizeFontWeightTokens(value);
    }
  }
};

const typographyTokenSegmentToCss = (segment, index) => {
  if (index === 0) {
    return segment.toLowerCase();
  }

  return segment
    .split(/[-_\s]+/)
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
};

const typographyPathToCssVariable = (pathSegments) => {
  if (pathSegments.length === 0) {
    return null;
  }

  const cssName = pathSegments
    .map((segment, index) => typographyTokenSegmentToCss(segment, index))
    .join('');
  return cssName ? `--${cssName}` : null;
};

const extractFontWeightReferenceValue = (value) => {
  if (typeof value === 'number') {
    return String(value);
  }

  if (typeof value !== 'string') {
    return null;
  }

  const trimmed = value.trim();
  if (/^\d+(\.\d+)?$/.test(trimmed)) {
    return trimmed;
  }

  const referenceMatch = trimmed.match(/^\{FontWeight\.([^}]+)\}$/);
  if (!referenceMatch) {
    return null;
  }

  const referenceKey = referenceMatch[1];
  if (/^\d+(\.\d+)?$/.test(referenceKey)) {
    return referenceKey;
  }

  const mapped = FONT_WEIGHT_NAME_TO_VALUE[referenceKey.toLowerCase()];
  return mapped ?? null;
};

const collectTypographyFontWeightOverrides = (tokenNode, path = []) => {
  if (!tokenNode || typeof tokenNode !== 'object' || Array.isArray(tokenNode)) {
    return {};
  }

  const overrides = {};

  for (const [key, value] of Object.entries(tokenNode)) {
    const nextPath = [...path, key];
    const normalizedPath = nextPath.filter((segment) => segment !== '$value');

    if (
      key === 'fontWeight' &&
      normalizedPath[0] === 'typography'
    ) {
      const resolvedValue = value && typeof value === 'object' ? value.$value : value;
      const cssVarName = typographyPathToCssVariable(normalizedPath);
      const cssVarValue = extractFontWeightReferenceValue(resolvedValue);

      if (cssVarName && cssVarValue) {
        overrides[cssVarName] = cssVarValue;
      }
    }

    if (value && typeof value === 'object') {
      Object.assign(overrides, collectTypographyFontWeightOverrides(value, nextPath));
    }
  }

  return overrides;
};

const applyTypographyFontWeightOverrides = (cssContent, overrides) =>
  Object.entries(overrides).reduce((nextCssContent, [cssVarName, cssVarValue]) => {
    const escapedVariableName = cssVarName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const declarationPattern = new RegExp(`(${escapedVariableName}:\\s*)([^;]+);`, 'g');
    return nextCssContent.replace(declarationPattern, `$1${cssVarValue};`);
  }, cssContent);

const resolveTokenSource = async (value) => {
  if (typeof value === 'string') {
    const absolute = path.resolve(TOKENS_DIR, value);
    return readJson(absolute);
  }
  return value;
};

const loadTokenBundle = async () => {
  const bundle = await readJson(TOKENS_FILE);

  const metadata = bundle.$metadata ? await resolveTokenSource(bundle.$metadata) : undefined;
  const themes = bundle.$themes ? await resolveTokenSource(bundle.$themes) : [];
  const setEntries = Object.entries(bundle.sets ?? {});
  const tokenSets = {};

  for (const [name, value] of setEntries) {
    if (typeof value === 'string') {
      const absolute = path.resolve(TOKENS_DIR, value);
      tokenSets[name] = {
        tokens: await readJson(absolute),
        path: absolute,
      };
    } else if (value && typeof value === 'object') {
      tokenSets[name] = {
        tokens: value,
        path: null,
      };
    } else {
      throw new Error(`Token set "${name}" must resolve to a JSON object or file path.`);
    }
  }

  for (const entry of Object.values(tokenSets)) {
    normalizeFontWeightTokens(entry.tokens);
  }

  return { metadata, themes, tokenSets };
};

const SOURCE_STATES = new Set(['enabled', 'source']);

const extractSetNames = (selectedTokenSets, prefix) => {
  if (!selectedTokenSets) {
    return [];
  }

  return Object.entries(selectedTokenSets)
    .filter(([setName, state]) => setName.startsWith(prefix) && SOURCE_STATES.has(state))
    .map(([setName]) => setName);
};

const resolveDictionarySource = (entry) => {
  if (entry.path) {
    return entry.path;
  }
  return { tokens: structuredClone(entry.tokens) };
};

const buildStyleDictionary = async ({
  externalSetNames,
  internalSetName,
  themeName,
  tokenSets,
  selector,
  slug,
}) => {
  const relativeOutputDir = path.relative(process.cwd(), THEMES_OUTPUT_DIR) || '.';
  const baseDictionary = new StyleDictionary();
  const externalEntries = externalSetNames.map((setName) => {
    const entry = tokenSets[setName];
    if (!entry) {
      throw new Error(`Token set "${setName}" is not defined in ${path.relative(ROOT_DIR, TOKENS_FILE)}`);
    }
    return entry;
  });
  const internalEntry = tokenSets[internalSetName];
  if (!internalEntry) {
    throw new Error(`Token set "${internalSetName}" is not defined in ${path.relative(ROOT_DIR, TOKENS_FILE)}`);
  }

  const externalFilePaths = new Set(externalEntries.map((entry) => entry.path).filter(Boolean));
  const internalFilePaths = new Set(internalEntry.path ? [internalEntry.path] : []);
  const filterToken = (token) => {
    if (externalFilePaths.size > 0) {
      return externalFilePaths.has(token.filePath);
    }
    if (internalFilePaths.size > 0) {
      return !internalFilePaths.has(token.filePath);
    }
    return true;
  };

  const dictionary = await baseDictionary.extend({
    include: [resolveDictionarySource(internalEntry)],
    source: externalEntries.map(resolveDictionarySource),
    expand: {
      typesMap: expandTypesMap,
    },
    platforms: {
      css: {
        transformGroup: 'tokens-studio',
        buildPath: relativeOutputDir.endsWith(path.sep)
          ? relativeOutputDir
          : `${relativeOutputDir}${path.sep}`,
        options: {
          showFileHeader: false,
          outputReferences: false,
        },
        files: [
          {
            destination: `${slug}.css`,
            format: 'css/variables',
            filter: filterToken,
          },
        ],
      },
    },
  });

  await dictionary.buildPlatform('css');

  const cssPath = path.join(THEMES_OUTPUT_DIR, `${slug}.css`);
  const cssContent = await fs.readFile(cssPath, 'utf8');
  const typographyWeightOverrides = externalEntries.reduce((allOverrides, entry) => {
    Object.assign(allOverrides, collectTypographyFontWeightOverrides(entry.tokens));
    return allOverrides;
  }, {});
  const overriddenTypographyCss = applyTypographyFontWeightOverrides(cssContent, typographyWeightOverrides);
  const augmentedCss = ensureStateLayerAliases(appendIntensityCompanionTokens(overriddenTypographyCss));
  const rewrittenCss = rewriteRootSelector({ cssContent: augmentedCss, selector });
  await fs.writeFile(cssPath, ensureBanner(rewrittenCss, CSS_BANNER), 'utf8');

  return {
    cssPath,
  };
};

const formatManifest = ({ themes, metadata }) => {
  const manifest = {
    themeAttribute: FIVRA_THEME_ATTRIBUTE,
    themes: themes.map((theme) => ({
      name: theme.theme.name,
      id: theme.theme.id,
      group: theme.theme.group ?? null,
      cssPath: `./${theme.slug}.css`,
      slug: theme.slug,
      selector: theme.selector,
      isDefault: theme.isDefault,
      selectedTokenSets: theme.theme.selectedTokenSets,
      activeTokenSets: [...theme.setCombination.external, theme.setCombination.internal],
      tokenSetCombination: {
        external: [...theme.setCombination.external],
        internal: theme.setCombination.internal,
      },
    })),
    metadata: metadata ?? null,
  };

  const manifestBody = `${TS_BANNER}export const designTokenManifest = ${JSON.stringify(manifest, null, 2)} as const;\n\nexport type DesignTokenTheme = typeof designTokenManifest.themes[number];\nexport type DesignTokenThemeName = DesignTokenTheme['name'];\nexport type DesignTokenThemeSlug = DesignTokenTheme['slug'];\n`;

  return manifestBody;
};

const toKebabToken = (value) =>
  value
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    .replace(/([a-zA-Z])([0-9])/g, '$1-$2')
    .replace(/([0-9])([a-zA-Z])/g, '$1-$2')
    .toLowerCase();

const dedupe = (values) => [...new Set(values)];

const extractCssVariableNames = (cssContent) =>
  [...cssContent.matchAll(/--([A-Za-z0-9]+):/g)].map((match) => match[1]);

const extractShadowTokenOptions = (cssVarNames) => {
  const byLevel = new Map();
  const shadowPattern = /^shadows([A-Za-z0-9]+?)(X|Y|Blur|Spread|Color|Type)$/;

  for (const cssVarName of cssVarNames) {
    const match = cssVarName.match(shadowPattern);
    if (!match) {
      continue;
    }

    const [, level, part] = match;
    const parts = byLevel.get(level) ?? new Set();
    parts.add(part);
    byLevel.set(level, parts);
  }

  const requiredParts = ['X', 'Y', 'Blur', 'Spread', 'Color'];

  return [...byLevel.entries()]
    .filter(([, parts]) => requiredParts.every((part) => parts.has(part)))
    .map(([level]) => `shadow-${toKebabToken(level)}`);
};

const collectStorybookTokenOptions = (cssContent) => {
  const cssVarNames = extractCssVariableNames(cssContent);
  const categoryTokens = (prefix) =>
    dedupe(
      cssVarNames
        .filter((name) => name.startsWith(prefix))
        .map((name) => toKebabToken(name)),
    );

  return {
    backgroundColorTokenOptions: categoryTokens('background'),
    borderColorTokenOptions: categoryTokens('border').filter(
      (token) => !token.startsWith('borderwidth-') && !token.startsWith('border-width-'),
    ),
    textColorTokenOptions: categoryTokens('text'),
    spacingTokenOptions: categoryTokens('spacing'),
    radiusTokenOptions: categoryTokens('radius'),
    borderWidthTokenOptions: categoryTokens('borderwidth').map((token) =>
      token.replace(/^borderwidth-/, 'border-width-'),
    ),
    shadowTokenOptions: extractShadowTokenOptions(cssVarNames),
  };
};

const formatStringArray = (values) =>
  values.map((value) => `  "${value}"`).join(',\n');

const formatStorybookTokenOptionsModule = (options) => `${TS_BANNER}export const backgroundColorTokenOptions = [
${formatStringArray(options.backgroundColorTokenOptions)}
] as const;

export const borderColorTokenOptions = [
${formatStringArray(options.borderColorTokenOptions)}
] as const;

export const textColorTokenOptions = [
${formatStringArray(options.textColorTokenOptions)}
] as const;

export const spacingTokenOptions = [
${formatStringArray(options.spacingTokenOptions)}
] as const;

export const radiusTokenOptions = [
${formatStringArray(options.radiusTokenOptions)}
] as const;

export const borderWidthTokenOptions = [
${formatStringArray(options.borderWidthTokenOptions)}
] as const;

export const shadowTokenOptions = [
${formatStringArray(options.shadowTokenOptions)}
] as const;

export const storybookTokenOptionMap = {
  backgroundColor: backgroundColorTokenOptions,
  borderColor: borderColorTokenOptions,
  textColor: textColorTokenOptions,
  spacing: spacingTokenOptions,
  radius: radiusTokenOptions,
  borderWidth: borderWidthTokenOptions,
  shadow: shadowTokenOptions,
} as const;
`;

const main = async () => {
  process.chdir(ROOT_DIR);
  await register(StyleDictionary, { platform: 'css' });

  const { metadata, themes, tokenSets } = await loadTokenBundle();
  if (!Array.isArray(themes) || themes.length === 0) {
    throw new Error(`No themes were found in ${path.relative(ROOT_DIR, TOKENS_FILE)}`);
  }

  await clearGeneratedThemeArtifacts();

  const manifestThemes = [];
  const externalTheme = themes.find((item) => item.group === 'Externals');
  if (!externalTheme) {
    throw new Error(`No theme with group "Externals" found in ${path.relative(ROOT_DIR, TOKENS_FILE)}`);
  }

  const externalSetNames = extractSetNames(externalTheme.selectedTokenSets, 'Externals/');
  if (externalSetNames.length === 0) {
    throw new Error(`Theme "${externalTheme.name}" does not enable any external token sets.`);
  }

  for (const [index, targetThemeName] of TARGET_THEMES.entries()) {
    const theme = themes.find((item) => item.name === targetThemeName);
    if (!theme) {
      throw new Error(`Theme "${targetThemeName}" is missing from ${path.relative(ROOT_DIR, TOKENS_FILE)}`);
    }

    const internalSetNames = extractSetNames(theme.selectedTokenSets, 'Internals/');
    if (internalSetNames.length !== 1) {
      throw new Error(
        `Theme "${targetThemeName}" must enable exactly one internal token set. Found ${internalSetNames.length}.`,
      );
    }

    const [internalSetName] = internalSetNames;

    const isDefault = index === 0;
    const slug = slugify(targetThemeName);
    const selector = formatThemeSelector({ slug, isDefault });

    const { cssPath } = await buildStyleDictionary({
      externalSetNames,
      internalSetName,
      themeName: targetThemeName,
      tokenSets,
      selector,
      slug,
    });
    manifestThemes.push({
      theme,
      slug,
      selector,
      isDefault,
      cssPath,
      setCombination: {
        external: [...externalSetNames],
        internal: internalSetName,
      },
    });
  }

  const manifestContent = formatManifest({
    themes: manifestThemes,
    metadata,
  });
  await fs.writeFile(MANIFEST_PATH, ensureBanner(manifestContent, TS_BANNER), 'utf8');

  const defaultTheme = manifestThemes.find((theme) => theme.isDefault) ?? manifestThemes[0];
  const defaultCssContent = await fs.readFile(defaultTheme.cssPath, 'utf8');
  const tokenOptions = collectStorybookTokenOptions(defaultCssContent);
  const storybookTokenOptionsContent = formatStorybookTokenOptionsModule(tokenOptions);
  await fs.writeFile(
    STORYBOOK_TOKEN_OPTIONS_PATH,
    ensureBanner(storybookTokenOptionsContent, TS_BANNER),
    'utf8',
  );
};

main().catch((error) => {
  console.error(`\nDesign token generation failed:`, error);
  process.exit(1);
});
